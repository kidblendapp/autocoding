name: AI Teammate Enhanced

on:
  workflow_dispatch:
    inputs:
      config_file:
        description: 'Path to config'
        required: false
        default: 'agents/test_agent.json'
      encoded_config:
        description: 'Encoded or JSON Agent Config'
        required: false
  
  repository_dispatch:
    types: 
      - ai-teammate-trigger
      - story-clarification
      - story-development
      - story-description
      - solution-design
      - sd-core-description
      - sd-api-description
      - api-development
      - core-description
      - code-review
      - test-generation

permissions:
  contents: write
  pull-requests: write
  actions: read
  
jobs:
  cursor-agent:
    runs-on: ubuntu-latest
    concurrency:
      group: cursor-agent-${{ github.event.client_payload.config_file || inputs.config_file || 'agents/test_agent.json' }}
      cancel-in-progress: false
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Map Event Type to Config
      id: map-config
      run: |
        EVENT_TYPE="${{ github.event.action }}"
        
        case "$EVENT_TYPE" in
          "story-clarification")
            CONFIG="agents/story_questions.json"
            ;;
          "story-development")
            CONFIG="agents/story_development.json"
            ;;
          "story-description")
            CONFIG="agents/story_description.json"
            ;;
          "solution-design")
            CONFIG="agents/story_solution_design.json"
            ;;
          "sd-core-description")
            CONFIG="agents/sd_core_description.json"
            ;;
          "sd-api-description")
            CONFIG="agents/sd_api_description.json"
            ;;
          "api-development")
            CONFIG="agents/api_development.json"
            ;;
          "core-description")
            CONFIG="agents/core_description.json"
            ;;
          "code-review")
            CONFIG="agents/code_review.json"
            ;;
          "test-generation")
            CONFIG="agents/test_cases_generator.json"
            ;;
          *)
            CONFIG="${{ github.event.client_payload.config_file }}"
            ;;
        esac
        
        echo "config_file=${CONFIG}" >> $GITHUB_OUTPUT
        echo "Mapped event type '${EVENT_TYPE}' to config: ${CONFIG}"

    - name: Prepare Configuration
      id: config
      run: |
        # Determine config file from either webhook or manual input
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          # Use mapped config if available, otherwise use client_payload
          CONFIG_FILE="${{ steps.map-config.outputs.config_file }}"
          ENCODED_CONFIG="${{ github.event.client_payload.encoded_config }}"
          TICKET_KEY="${{ github.event.client_payload.ticket_key }}"
          JQL_QUERY="${{ github.event.client_payload.jql_query }}"
        else
          # Use provided config_file or default to agents/test_agent.json
          CONFIG_FILE="${{ inputs.config_file }}"
          if [ -z "${CONFIG_FILE}" ]; then
            CONFIG_FILE="agents/test_agent.json"
          fi
          ENCODED_CONFIG="${{ inputs.encoded_config }}"
          TICKET_KEY=""
          JQL_QUERY=""
        fi
        
        echo "config_file=${CONFIG_FILE}" >> $GITHUB_OUTPUT
        echo "encoded_config=${ENCODED_CONFIG}" >> $GITHUB_OUTPUT
        echo "ticket_key=${TICKET_KEY}" >> $GITHUB_OUTPUT
        echo "jql_query=${JQL_QUERY}" >> $GITHUB_OUTPUT
        
        echo "Configuration: ${CONFIG_FILE}"
        echo "Ticket: ${TICKET_KEY}"
        echo "JQL: ${JQL_QUERY}"

    - name: Update Config with Ticket Key
      if: steps.config.outputs.ticket_key != ''
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        TICKET_KEY="${{ steps.config.outputs.ticket_key }}"
        
        # Update JQL in config to use specific ticket
        jq --arg key "$TICKET_KEY" '.params.inputJql = "key = \($key)"' \
          "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
        mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
        
        echo "Updated config with ticket: $TICKET_KEY"

    - name: Update Config with JQL Query
      if: steps.config.outputs.jql_query != ''
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        JQL_QUERY="${{ steps.config.outputs.jql_query }}"
        
        # Update JQL in config
        jq --arg jql "$JQL_QUERY" '.params.inputJql = $jql' \
          "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
        mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
        
        echo "Updated config with JQL: $JQL_QUERY"

    # ✅ ИСПРАВЛЕНО: Используем стандартный action
    - name: Setup Java Environment
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '23'
        # Removed cache: 'maven' - repository doesn't have pom.xml (Node.js/TypeScript project)

    - name: Install Cursor CLI
      run: |
        echo "Installing Cursor CLI..."
        curl https://cursor.com/install -fsS | bash
        
        echo "Checking installation locations..."
        ls -la "$HOME/.cursor/" || echo "No .cursor directory"
        ls -la "$HOME/.cursor/bin/" || echo "No .cursor/bin directory"
        ls -la "$HOME/.local/bin/" || echo "No .local/bin directory"
        
        # Cursor CLI installs to ~/.local/bin, not ~/.cursor/bin
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
        # Test installation
        export PATH="$HOME/.local/bin:$PATH"
        if command -v cursor-agent; then
          echo "✅ cursor-agent found at: $(command -v cursor-agent)"
          cursor-agent --version 2>&1 || echo "Version check failed"
        else
          echo "❌ cursor-agent not found after installation"
          echo "Available files in .local/bin:"
          ls -la "$HOME/.local/bin/" 2>/dev/null || echo "Directory does not exist"
        fi

    - name: Install DMTools CLI
      run: |
        curl -fsSL https://github.com/IstiN/dmtools/releases/latest/download/install.sh | bash
        echo "$HOME/.dmtools/bin" >> $GITHUB_PATH

    - name: Verify DMTools and Cursor Installation
      run: |
        echo "Verifying installations..."
        export PATH="$HOME/.local/bin:$HOME/.dmtools/bin:$PATH"
        
        echo "DMTools version:"
        dmtools --version || echo "⚠️ dmtools not found"
        
        echo "Cursor Agent version:"
        cursor-agent --version || echo "⚠️ cursor-agent not found"
        
        echo "PATH: $PATH"

    - name: Prepare Environment Variables
      id: env-prep
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        
        # Check if this is test_agent
        if [[ "${CONFIG_FILE}" == *"test_agent.json"* ]]; then
          echo "is_test_agent=true" >> $GITHUB_OUTPUT
          echo "dmtools_integrations=cli,file" >> $GITHUB_OUTPUT
          echo "Test agent detected - will disable Jira/Confluence integrations"
        else
          echo "is_test_agent=false" >> $GITHUB_OUTPUT
          echo "dmtools_integrations=jira,confluence,figma,ai,cli,file" >> $GITHUB_OUTPUT
        fi

    - name: Run AI Teammate
      env:
        CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        MODEL: sonnet-4
        AGENT_DISABLE_WATCHDOG: "1"
        PATH: "/home/runner/.local/bin:/home/runner/.dmtools/bin:/bin:/usr/bin:$PATH"
        
        # Jira Configuration (will be overridden in script for test_agent)
        JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
        JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
        JIRA_CLEAR_CACHE: ${{ vars.JIRA_CLEAR_CACHE }}
        JIRA_EXTRA_FIELDS: ${{ vars.JIRA_EXTRA_FIELDS }}
        JIRA_EXTRA_FIELDS_PROJECT: ${{ vars.JIRA_EXTRA_FIELDS_PROJECT }}
        JIRA_LOGGING_ENABLED: ${{ vars.JIRA_LOGGING_ENABLED }}
        JIRA_WAIT_BEFORE_PERFORM: ${{ vars.JIRA_WAIT_BEFORE_PERFORM }}

        # Confluence Configuration (will be overridden in script for test_agent)
        CONFLUENCE_EMAIL: ${{ secrets.JIRA_EMAIL }}
        CONFLUENCE_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        CONFLUENCE_BASE_PATH: ${{ vars.CONFLUENCE_BASE_PATH }}
        CONFLUENCE_DEFAULT_SPACE: ${{ vars.CONFLUENCE_DEFAULT_SPACE }}
        CONFLUENCE_GRAPHQL_PATH: ${{ vars.CONFLUENCE_GRAPHQL_PATH }}

        # DMTools Integration Settings (uses computed value from env-prep step)
        DMTOOLS_INTEGRATIONS: ${{ steps.env-prep.outputs.dmtools_integrations }}

        # AI Service Configuration
        # Note: GEMINI_API_KEY may be required even when skipAIProcessing=true
        # For test agents, we'll set it to empty string in the script if needed
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GEMINI_DEFAULT_MODEL: ${{ vars.GEMINI_DEFAULT_MODEL }}
        PROMPT_CHUNK_TOKEN_LIMIT: ${{ vars.PROMPT_CHUNK_TOKEN_LIMIT }}
        
        # Figma Configuration
        FIGMA_TOKEN: ${{ secrets.FIGMA_TOKEN }}
        FIGMA_BASE_PATH: ${{ vars.FIGMA_BASE_PATH }}
        
        # GitHub Authentication for PR creation
        PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      run: | 
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        ENCODED_CONFIG="${{ steps.config.outputs.encoded_config }}"
        
        # ✅ CRITICAL: Export PATH to ensure dmtools is available
        export PATH="$HOME/.local/bin:$HOME/.dmtools/bin:$PATH"
        
        # ✅ CRITICAL: Explicitly export DMTOOLS_INTEGRATIONS to ensure it's available to dmtools
        export DMTOOLS_INTEGRATIONS="${{ steps.env-prep.outputs.dmtools_integrations }}"
        
        echo "Using configuration: ${CONFIG_FILE}"
        
        # ✅ Verify dmtools is available before proceeding
        echo "=== Verifying dmtools installation ==="
        if ! command -v dmtools >/dev/null 2>&1; then
          echo "❌ dmtools command not found in PATH"
          echo "Current PATH: $PATH"
          echo "Checking installation locations:"
          ls -la "$HOME/.dmtools/bin/" 2>/dev/null || echo "  $HOME/.dmtools/bin/ does not exist"
          ls -la "$HOME/.local/bin/" 2>/dev/null || echo "  $HOME/.local/bin/ does not exist"
          echo "Trying to find dmtools:"
          find "$HOME" -name "dmtools" -type f 2>/dev/null | head -5 || echo "  dmtools not found in $HOME"
          exit 1
        fi
        echo "✅ dmtools found at: $(command -v dmtools)"
        dmtools --version || echo "⚠️ Version check failed, but continuing..."
        echo "======================================"
        echo ""
        
        # ✅ Check config file exists
        if [ ! -f "${CONFIG_FILE}" ]; then
          echo "❌ Config file not found: ${CONFIG_FILE}"
          echo "Available files in agents/:"
          ls -la agents/ || echo "agents/ directory not found"
          exit 1
        fi
        
        # ✅ Ensure config file is writable (fix permission issues)
        chmod 644 "${CONFIG_FILE}" || echo "⚠️ Could not change config file permissions (may be read-only)"
        
        # For test_agent, unset Jira/Confluence env vars to prevent initialization
        if [[ "${{ steps.env-prep.outputs.is_test_agent }}" == "true" ]]; then
          echo "Test agent detected - unsetting Jira/Confluence env vars"
          # Unset Jira/Confluence env vars to prevent initialization
          unset JIRA_EMAIL JIRA_API_TOKEN JIRA_BASE_PATH JIRA_AUTH_TYPE
          unset JIRA_CLEAR_CACHE JIRA_EXTRA_FIELDS JIRA_EXTRA_FIELDS_PROJECT
          unset JIRA_LOGGING_ENABLED JIRA_WAIT_BEFORE_PERFORM
          unset CONFLUENCE_EMAIL CONFLUENCE_API_TOKEN CONFLUENCE_BASE_PATH
          unset CONFLUENCE_DEFAULT_SPACE CONFLUENCE_GRAPHQL_PATH
          echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
          echo "Jira/Confluence env vars unset"
        fi
        
        # ✅ Ensure outputs directory exists and is writable with proper permissions
        mkdir -p outputs inputs
        chmod 755 outputs inputs || true
        # Ensure current directory is writable
        chmod 755 . || true
        echo "Created outputs and inputs directories"
        echo "Directory permissions:"
        ls -ld outputs inputs . || true
        
        # For test_agent, ensure inputJql exists but won't cause Jira queries
        # dmtools may require inputJql to be present even if it's not used
        if [[ "${{ steps.env-prep.outputs.is_test_agent }}" == "true" ]]; then
          echo "Ensuring test agent config has required fields"
          TEMP_CONFIG="${CONFIG_FILE}.tmp"
          
          # Check if inputJql exists, if not add a dummy one
          if ! jq -e '.params.inputJql' "${CONFIG_FILE}" > /dev/null 2>&1; then
            echo "Adding dummy inputJql to test agent config"
            if jq '.params.inputJql = "key = TEST-NEVER-MATCHES-99999"' "${CONFIG_FILE}" > "${TEMP_CONFIG}" 2>/dev/null; then
              if mv "${TEMP_CONFIG}" "${CONFIG_FILE}" 2>/dev/null; then
                chmod 644 "${CONFIG_FILE}" || true
                echo "✅ Added dummy inputJql to config"
              else
                CONFIG_FILE="$(realpath "${TEMP_CONFIG}" 2>/dev/null || echo "${TEMP_CONFIG}")"
                chmod 644 "${CONFIG_FILE}" || true
                echo "Using temp config file: ${CONFIG_FILE}"
              fi
            else
              echo "⚠️ Failed to add inputJql (jq error)"
              rm -f "${TEMP_CONFIG}"
            fi
          else
            echo "inputJql already exists in config"
          fi
          
          # Ensure ticketContextDepth is set (default to 0 for test agents)
          if ! jq -e '.params.ticketContextDepth' "${CONFIG_FILE}" > /dev/null 2>&1; then
            echo "Adding ticketContextDepth to test agent config"
            TEMP_CONFIG="${CONFIG_FILE}.tmp"
            if jq '.params.ticketContextDepth = 0' "${CONFIG_FILE}" > "${TEMP_CONFIG}" 2>/dev/null; then
              if mv "${TEMP_CONFIG}" "${CONFIG_FILE}" 2>/dev/null; then
                chmod 644 "${CONFIG_FILE}" || true
                echo "✅ Added ticketContextDepth to config"
              else
                CONFIG_FILE="$(realpath "${TEMP_CONFIG}" 2>/dev/null || echo "${TEMP_CONFIG}")"
                chmod 644 "${CONFIG_FILE}" || true
              fi
            else
              rm -f "${TEMP_CONFIG}"
            fi
          fi
          
          echo "Final test agent config:"
          cat "${CONFIG_FILE}" | jq '.' || cat "${CONFIG_FILE}"
          
          # Ensure GEMINI_API_KEY is set (even if empty) for test agent to prevent validation errors
          export GEMINI_API_KEY="${GEMINI_API_KEY:-}"
          echo "GEMINI_API_KEY is set (may be empty for test agent)"
        fi
        
        # ✅ Ensure CONFIG_FILE is absolute path for dmtools
        CONFIG_FILE="$(realpath "${CONFIG_FILE}" 2>/dev/null || echo "${CONFIG_FILE}")"
        echo "Final config file path: ${CONFIG_FILE}"
        
        # ✅ Final permission and accessibility checks before running dmtools
        echo ""
        echo "=== Pre-flight checks ==="
        if [ ! -f "${CONFIG_FILE}" ]; then
          echo "❌ Config file does not exist: ${CONFIG_FILE}"
          exit 1
        fi
        if [ ! -r "${CONFIG_FILE}" ]; then
          echo "❌ Config file is not readable: ${CONFIG_FILE}"
          exit 1
        fi
        echo "✅ Config file exists and is readable"
        
        if [ ! -d "outputs" ]; then
          echo "❌ Outputs directory does not exist"
          exit 1
        fi
        if [ ! -w "outputs" ]; then
          echo "❌ Outputs directory is not writable"
          chmod 755 outputs || exit 1
        fi
        echo "✅ Outputs directory exists and is writable"
        echo "=========================="
        echo ""
        
        # Validate config file JSON syntax before running
        echo "Validating config file JSON syntax..."
        if ! jq empty "${CONFIG_FILE}" 2>/dev/null; then
          echo "❌ Config file has invalid JSON syntax"
          echo "Config file content:"
          cat "${CONFIG_FILE}"
          exit 1
        fi
        echo "✅ Config file JSON is valid"
        
        # Debug: Show environment before running
        echo "=== Environment Debug ==="
        echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
        echo "JIRA_EMAIL: ${JIRA_EMAIL:-<not set>}"
        echo "JIRA_BASE_PATH: ${JIRA_BASE_PATH:-<not set>}"
        echo "PATH: $PATH"
        echo "========================="
        
        # Run dmtools with improved error handling
        echo ""
        echo "=== Running dmtools ==="
        echo "Config file: ${CONFIG_FILE}"
        echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
        echo "GEMINI_API_KEY: ${GEMINI_API_KEY:+<set>}${GEMINI_API_KEY:-<not set>}"
        echo "Working directory: $(pwd)"
        echo "Directory permissions:"
        ls -ld . outputs inputs 2>/dev/null || true
        
        # ✅ Ensure we have write permissions in current directory
        touch .write-test 2>/dev/null && rm -f .write-test && echo "✅ Current directory is writable" || echo "⚠️ Current directory may not be writable"
        
        # Run with explicit environment variables to ensure dmtools sees them
        # Capture both stdout and stderr, and also save exit code
        # Use a reliable method: run command, capture output to file, then display it
        set +e  # Don't exit on error, we'll handle it manually
        
        # Add Java debugging - enable verbose logging for better error visibility
        # This helps diagnose dmtools execution issues
        export JAVA_OPTS="${JAVA_OPTS:-} -Djava.util.logging.ConsoleHandler.level=INFO"
        
        # For test agents, enable even more verbose logging
        if [[ "${{ steps.env-prep.outputs.is_test_agent }}" == "true" ]]; then
          export JAVA_OPTS="${JAVA_OPTS} -Djava.util.logging.ConsoleHandler.level=FINE"
          echo "Verbose logging enabled for test agent"
        fi
        
        if [ -n "${ENCODED_CONFIG}" ]; then
          echo "Encoded config provided"
          # Run dmtools and capture all output
          env DMTOOLS_INTEGRATIONS="${DMTOOLS_INTEGRATIONS}" \
              GEMINI_API_KEY="${GEMINI_API_KEY:-}" \
              JAVA_OPTS="${JAVA_OPTS}" \
            dmtools run "${CONFIG_FILE}" "${ENCODED_CONFIG}" > /tmp/dmtools-output.log 2>&1
          EXIT_CODE=$?
        else
          echo "No encoded config"
          # Run dmtools and capture all output
          env DMTOOLS_INTEGRATIONS="${DMTOOLS_INTEGRATIONS}" \
              GEMINI_API_KEY="${GEMINI_API_KEY:-}" \
              JAVA_OPTS="${JAVA_OPTS}" \
            dmtools run "${CONFIG_FILE}" > /tmp/dmtools-output.log 2>&1
          EXIT_CODE=$?
        fi
        
        # Display the output
        cat /tmp/dmtools-output.log
        
        # Check for common error patterns in the output
        if [ $EXIT_CODE -ne 0 ]; then
          echo ""
          echo "=== Analyzing dmtools output for errors ==="
          
          # Check for specific error patterns
          if grep -i "exception\|error\|failed\|cannot\|unable" /tmp/dmtools-output.log 2>/dev/null; then
            echo "Found error patterns in output (see above)"
          else
            echo "No obvious error patterns found, but exit code is $EXIT_CODE"
          fi
          
          # Show last 50 lines for better context
          echo ""
          echo "Last 50 lines of dmtools output:"
          tail -50 /tmp/dmtools-output.log 2>/dev/null || echo "Could not read output log"
          
          # Check if cliCommands were executed by looking for their output
          echo ""
          echo "=== Checking if cliCommands executed ==="
          if grep -i "Hello from AI Teammate\|Test Result\|Agent executed successfully" /tmp/dmtools-output.log 2>/dev/null; then
            echo "✅ cliCommands appear to have executed (found expected output)"
          else
            echo "❌ cliCommands may not have executed (expected output not found)"
          fi
          
          # Check for ticket processing issues
          if grep -i "no tickets\|ticket not found\|empty result" /tmp/dmtools-output.log 2>/dev/null; then
            echo "⚠️ Ticket processing issue detected (this may be expected for test agents)"
          fi
          
          echo "=========================================="
        fi
        
        set -e  # Re-enable exit on error
        
        echo ""
        echo "=== dmtools finished with exit code: $EXIT_CODE ==="
        
        # Check exit code and provide helpful error message
        if [ $EXIT_CODE -ne 0 ]; then
          echo ""
          echo "❌ dmtools exited with code: $EXIT_CODE"
          echo ""
          echo "=== Full dmtools output ==="
          cat /tmp/dmtools-output.log 2>/dev/null || echo "Could not read output log"
          echo "=========================="
          echo ""
          echo "=== Permission Checks ==="
          echo "Current directory: $(pwd)"
          echo "Current directory permissions:"
          ls -ld . 2>/dev/null || echo "Could not check current directory"
          echo ""
          echo "Config file permissions:"
          ls -l "${CONFIG_FILE}" 2>/dev/null || echo "Could not check config file"
          echo ""
          echo "Outputs directory permissions:"
          ls -ld outputs 2>/dev/null || echo "Outputs directory does not exist"
          echo ""
          echo "Testing write permissions:"
          touch outputs/.write-test 2>/dev/null && rm -f outputs/.write-test && echo "✅ outputs/ is writable" || echo "❌ outputs/ is NOT writable"
          touch .write-test 2>/dev/null && rm -f .write-test && echo "✅ Current directory is writable" || echo "❌ Current directory is NOT writable"
          echo "=========================="
          echo ""
          echo "=== Additional Debug Info ==="
          echo "DMTOOLS_INTEGRATIONS value: '${DMTOOLS_INTEGRATIONS}'"
          echo "GEMINI_API_KEY: ${GEMINI_API_KEY:+<set>}${GEMINI_API_KEY:-<not set>}"
          echo "Config file path: ${CONFIG_FILE}"
          echo "Config file exists: $([ -f "${CONFIG_FILE}" ] && echo 'yes' || echo 'no')"
          echo "Config file readable: $([ -r "${CONFIG_FILE}" ] && echo 'yes' || echo 'no')"
          echo "Config file writable: $([ -w "${CONFIG_FILE}" ] && echo 'yes' || echo 'no')"
          echo ""
          echo "Checking for output files..."
          ls -la outputs/ 2>/dev/null || echo "No outputs/ directory"
          ls -la inputs/ 2>/dev/null || echo "No inputs/ directory"
          echo ""
          echo "Checking if cliCommands were executed..."
          if [ -f "outputs/response.md" ]; then
            echo "✅ outputs/response.md exists:"
            cat outputs/response.md || echo "Could not read response.md"
          else
            echo "❌ outputs/response.md does not exist - cliCommands may not have executed"
          fi
          echo ""
          echo "Config file content:"
          cat "${CONFIG_FILE}" || echo "Could not read config file"
          echo "======================"
          
          # Check for permission-related errors in output
          echo ""
          echo "=== Checking for permission errors ==="
          if grep -i "permission\|denied\|access\|read-only\|cannot write\|cannot create" /tmp/dmtools-output.log 2>/dev/null; then
            echo "⚠️ Permission-related errors detected in dmtools output"
          else
            echo "No obvious permission errors found in output"
          fi
          echo "===================================="
          
          # Try to get more verbose output if available
          echo ""
          echo "=== Checking dmtools help/version for clues ==="
          dmtools --version 2>&1 || true
          echo "=============================================="
          
          exit $EXIT_CODE
        else
          echo "✅ dmtools completed successfully"
          echo "Output files:"
          ls -la outputs/ 2>/dev/null || echo "No outputs created"
        fi

    # ✅ ИСПРАВЛЕНО: Добавлена проверка существования папок
    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ai-teammate-results-${{ github.run_number }}
        path: |
          outputs/
          inputs/
        retention-days: 30
        if-no-files-found: warn