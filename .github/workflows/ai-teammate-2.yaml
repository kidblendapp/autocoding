name: AI Teammate Enhanced

on:
  workflow_dispatch:
    inputs:
      config_file:
        description: 'Path to config'
        required: false
        default: 'agents/test_agent.json'
      encoded_config:
        description: 'Encoded or JSON Agent Config'
        required: false
  
  repository_dispatch:
    types: 
      - ai-teammate-trigger
      - story-clarification
      - story-development
      - story-description
      - solution-design
      - sd-core-description
      - sd-api-description
      - api-development
      - core-description
      - code-review
      - test-generation

permissions:
  contents: write
  pull-requests: write
  actions: read
  
jobs:
  cursor-agent:
    runs-on: ubuntu-latest
    concurrency:
      group: cursor-agent-${{ github.event.client_payload.config_file || inputs.config_file || 'agents/test_agent.json' }}
      cancel-in-progress: false
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Map Event Type to Config
      id: map-config
      run: |
        EVENT_TYPE="${{ github.event.action }}"
        
        case "$EVENT_TYPE" in
          "story-clarification")
            CONFIG="agents/story_questions.json"
            ;;
          "story-development")
            CONFIG="agents/story_development.json"
            ;;
          "story-description")
            CONFIG="agents/story_description.json"
            ;;
          "solution-design")
            CONFIG="agents/story_solution_design.json"
            ;;
          "sd-core-description")
            CONFIG="agents/sd_core_description.json"
            ;;
          "sd-api-description")
            CONFIG="agents/sd_api_description.json"
            ;;
          "api-development")
            CONFIG="agents/api_development.json"
            ;;
          "core-description")
            CONFIG="agents/core_description.json"
            ;;
          "code-review")
            CONFIG="agents/code_review.json"
            ;;
          "test-generation")
            CONFIG="agents/test_cases_generator.json"
            ;;
          *)
            CONFIG="${{ github.event.client_payload.config_file }}"
            ;;
        esac
        
        echo "config_file=${CONFIG}" >> $GITHUB_OUTPUT
        echo "Mapped event type '${EVENT_TYPE}' to config: ${CONFIG}"

    - name: Prepare Configuration
      id: config
      run: |
        # Determine config file from either webhook or manual input
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          # Use mapped config if available, otherwise use client_payload
          CONFIG_FILE="${{ steps.map-config.outputs.config_file }}"
          ENCODED_CONFIG="${{ github.event.client_payload.encoded_config }}"
          TICKET_KEY="${{ github.event.client_payload.ticket_key }}"
          JQL_QUERY="${{ github.event.client_payload.jql_query }}"
        else
          # Use provided config_file or default to agents/test_agent.json
          CONFIG_FILE="${{ inputs.config_file }}"
          if [ -z "${CONFIG_FILE}" ]; then
            CONFIG_FILE="agents/test_agent.json"
          fi
          ENCODED_CONFIG="${{ inputs.encoded_config }}"
          TICKET_KEY=""
          JQL_QUERY=""
        fi
        
        echo "config_file=${CONFIG_FILE}" >> $GITHUB_OUTPUT
        echo "encoded_config=${ENCODED_CONFIG}" >> $GITHUB_OUTPUT
        echo "ticket_key=${TICKET_KEY}" >> $GITHUB_OUTPUT
        echo "jql_query=${JQL_QUERY}" >> $GITHUB_OUTPUT
        
        echo "Configuration: ${CONFIG_FILE}"
        echo "Ticket: ${TICKET_KEY}"
        echo "JQL: ${JQL_QUERY}"

    - name: Update Config with Ticket Key
      if: steps.config.outputs.ticket_key != ''
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        TICKET_KEY="${{ steps.config.outputs.ticket_key }}"
        
        # Update JQL in config to use specific ticket
        jq --arg key "$TICKET_KEY" '.params.inputJql = "key = \($key)"' \
          "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
        mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
        
        echo "Updated config with ticket: $TICKET_KEY"

    - name: Update Config with JQL Query
      if: steps.config.outputs.jql_query != ''
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        JQL_QUERY="${{ steps.config.outputs.jql_query }}"
        
        # Update JQL in config
        jq --arg jql "$JQL_QUERY" '.params.inputJql = $jql' \
          "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
        mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
        
        echo "Updated config with JQL: $JQL_QUERY"

    # ✅ ИСПРАВЛЕНО: Используем стандартный action
    - name: Setup Java Environment
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '23'
        # Removed cache: 'maven' - repository doesn't have pom.xml (Node.js/TypeScript project)

    - name: Install Cursor CLI
      run: |
        echo "Installing Cursor CLI..."
        curl https://cursor.com/install -fsS | bash
        
        echo "Checking installation locations..."
        ls -la "$HOME/.cursor/" || echo "No .cursor directory"
        ls -la "$HOME/.cursor/bin/" || echo "No .cursor/bin directory"
        ls -la "$HOME/.local/bin/" || echo "No .local/bin directory"
        
        # Cursor CLI installs to ~/.local/bin, not ~/.cursor/bin
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
        # Test installation
        export PATH="$HOME/.local/bin:$PATH"
        if command -v cursor-agent; then
          echo "✅ cursor-agent found at: $(command -v cursor-agent)"
          cursor-agent --version 2>&1 || echo "Version check failed"
        else
          echo "❌ cursor-agent not found after installation"
          echo "Available files in .local/bin:"
          ls -la "$HOME/.local/bin/" 2>/dev/null || echo "Directory does not exist"
        fi

    - name: Install DMTools CLI
      run: |
        curl -fsSL https://github.com/IstiN/dmtools/releases/latest/download/install.sh | bash
        echo "$HOME/.dmtools/bin" >> $GITHUB_PATH

    - name: Verify DMTools and Cursor Installation
      run: |
        echo "Verifying installations..."
        export PATH="$HOME/.local/bin:$HOME/.dmtools/bin:$PATH"
        
        echo "DMTools version:"
        dmtools --version || echo "⚠️ dmtools not found"
        
        echo "Cursor Agent version:"
        cursor-agent --version || echo "⚠️ cursor-agent not found"
        
        echo "PATH: $PATH"

    - name: Prepare Environment Variables
      id: env-prep
      run: |
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        
        # Check if this is test_agent
        if [[ "${CONFIG_FILE}" == *"test_agent.json"* ]]; then
          echo "is_test_agent=true" >> $GITHUB_OUTPUT
          echo "dmtools_integrations=cli,file" >> $GITHUB_OUTPUT
          echo "Test agent detected - will disable Jira/Confluence integrations"
        else
          echo "is_test_agent=false" >> $GITHUB_OUTPUT
          echo "dmtools_integrations=jira,confluence,figma,ai,cli,file" >> $GITHUB_OUTPUT
        fi

    - name: Run AI Teammate
      env:
        CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        MODEL: sonnet-4
        AGENT_DISABLE_WATCHDOG: "1"
        PATH: "/home/runner/.local/bin:/home/runner/.dmtools/bin:/bin:/usr/bin:$PATH"
        
        # Jira Configuration (will be overridden in script for test_agent)
        JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
        JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
        JIRA_CLEAR_CACHE: ${{ vars.JIRA_CLEAR_CACHE }}
        JIRA_EXTRA_FIELDS: ${{ vars.JIRA_EXTRA_FIELDS }}
        JIRA_EXTRA_FIELDS_PROJECT: ${{ vars.JIRA_EXTRA_FIELDS_PROJECT }}
        JIRA_LOGGING_ENABLED: ${{ vars.JIRA_LOGGING_ENABLED }}
        JIRA_WAIT_BEFORE_PERFORM: ${{ vars.JIRA_WAIT_BEFORE_PERFORM }}

        # Confluence Configuration (will be overridden in script for test_agent)
        CONFLUENCE_EMAIL: ${{ secrets.JIRA_EMAIL }}
        CONFLUENCE_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        CONFLUENCE_BASE_PATH: ${{ vars.CONFLUENCE_BASE_PATH }}
        CONFLUENCE_DEFAULT_SPACE: ${{ vars.CONFLUENCE_DEFAULT_SPACE }}
        CONFLUENCE_GRAPHQL_PATH: ${{ vars.CONFLUENCE_GRAPHQL_PATH }}

        # DMTools Integration Settings (uses computed value from env-prep step)
        DMTOOLS_INTEGRATIONS: ${{ steps.env-prep.outputs.dmtools_integrations }}

        # AI Service Configuration
        # Note: GEMINI_API_KEY may be required even when skipAIProcessing=true
        # For test agents, we'll set it to empty string in the script if needed
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GEMINI_DEFAULT_MODEL: ${{ vars.GEMINI_DEFAULT_MODEL }}
        PROMPT_CHUNK_TOKEN_LIMIT: ${{ vars.PROMPT_CHUNK_TOKEN_LIMIT }}
        
        # Figma Configuration
        FIGMA_TOKEN: ${{ secrets.FIGMA_TOKEN }}
        FIGMA_BASE_PATH: ${{ vars.FIGMA_BASE_PATH }}
        
        # GitHub Authentication for PR creation
        PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      run: | 
        CONFIG_FILE="${{ steps.config.outputs.config_file }}"
        ENCODED_CONFIG="${{ steps.config.outputs.encoded_config }}"
        
        # ✅ CRITICAL: Export PATH to ensure dmtools is available
        export PATH="$HOME/.local/bin:$HOME/.dmtools/bin:$PATH"
        
        # ✅ CRITICAL: Explicitly export DMTOOLS_INTEGRATIONS to ensure it's available to dmtools
        export DMTOOLS_INTEGRATIONS="${{ steps.env-prep.outputs.dmtools_integrations }}"
        
        echo "Using configuration: ${CONFIG_FILE}"
        
        # ✅ Verify dmtools is available before proceeding
        echo "=== Verifying dmtools installation ==="
        if ! command -v dmtools >/dev/null 2>&1; then
          echo "❌ dmtools command not found in PATH"
          echo "Current PATH: $PATH"
          echo "Checking installation locations:"
          ls -la "$HOME/.dmtools/bin/" 2>/dev/null || echo "  $HOME/.dmtools/bin/ does not exist"
          ls -la "$HOME/.local/bin/" 2>/dev/null || echo "  $HOME/.local/bin/ does not exist"
          echo "Trying to find dmtools:"
          find "$HOME" -name "dmtools" -type f 2>/dev/null | head -5 || echo "  dmtools not found in $HOME"
          exit 1
        fi
        echo "✅ dmtools found at: $(command -v dmtools)"
        dmtools --version || echo "⚠️ Version check failed, but continuing..."
        echo "======================================"
        echo ""
        
        # ✅ Check config file exists
        if [ ! -f "${CONFIG_FILE}" ]; then
          echo "❌ Config file not found: ${CONFIG_FILE}"
          echo "Available files in agents/:"
          ls -la agents/ || echo "agents/ directory not found"
          exit 1
        fi
        
        # For test_agent, unset Jira/Confluence env vars to prevent initialization
        if [[ "${{ steps.env-prep.outputs.is_test_agent }}" == "true" ]]; then
          echo "Test agent detected - unsetting Jira/Confluence env vars"
          # Unset Jira/Confluence env vars to prevent initialization
          unset JIRA_EMAIL JIRA_API_TOKEN JIRA_BASE_PATH JIRA_AUTH_TYPE
          unset JIRA_CLEAR_CACHE JIRA_EXTRA_FIELDS JIRA_EXTRA_FIELDS_PROJECT
          unset JIRA_LOGGING_ENABLED JIRA_WAIT_BEFORE_PERFORM
          unset CONFLUENCE_EMAIL CONFLUENCE_API_TOKEN CONFLUENCE_BASE_PATH
          unset CONFLUENCE_DEFAULT_SPACE CONFLUENCE_GRAPHQL_PATH
          echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
          echo "Jira/Confluence env vars unset"
        fi
        
        # Ensure outputs directory exists and is writable
        mkdir -p outputs inputs
        chmod 755 outputs inputs || true
        echo "Created outputs and inputs directories"
        
        # For test_agent, remove inputJql field to prevent Jira queries
        if [[ "${{ steps.env-prep.outputs.is_test_agent }}" == "true" ]]; then
          echo "Removing inputJql from test agent config to prevent Jira initialization"
          # Use temporary file to avoid modifying source if jq fails
          if jq 'del(.params.inputJql)' "${CONFIG_FILE}" > "${CONFIG_FILE}.tmp" 2>/dev/null; then
            mv "${CONFIG_FILE}.tmp" "${CONFIG_FILE}"
            echo "✅ Removed inputJql from config"
            echo "Updated config:"
            cat "${CONFIG_FILE}" | jq '.' || cat "${CONFIG_FILE}"
          else
            echo "⚠️ Failed to remove inputJql (may not exist or jq error)"
            rm -f "${CONFIG_FILE}.tmp"
          fi
          
          # Ensure GEMINI_API_KEY is set (even if empty) for test agent to prevent validation errors
          # Some dmtools components may require this env var to be present
          export GEMINI_API_KEY="${GEMINI_API_KEY:-}"
          echo "GEMINI_API_KEY is set (may be empty for test agent)"
        fi
        
        # Validate config file JSON syntax before running
        echo "Validating config file JSON syntax..."
        if ! jq empty "${CONFIG_FILE}" 2>/dev/null; then
          echo "❌ Config file has invalid JSON syntax"
          echo "Config file content:"
          cat "${CONFIG_FILE}"
          exit 1
        fi
        echo "✅ Config file JSON is valid"
        
        # Debug: Show environment before running
        echo "=== Environment Debug ==="
        echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
        echo "JIRA_EMAIL: ${JIRA_EMAIL:-<not set>}"
        echo "JIRA_BASE_PATH: ${JIRA_BASE_PATH:-<not set>}"
        echo "PATH: $PATH"
        echo "========================="
        
        # Run dmtools with improved error handling
        echo ""
        echo "=== Running dmtools ==="
        echo "Config file: ${CONFIG_FILE}"
        echo "DMTOOLS_INTEGRATIONS: ${DMTOOLS_INTEGRATIONS}"
        echo "GEMINI_API_KEY: ${GEMINI_API_KEY:+<set>}${GEMINI_API_KEY:-<not set>}"
        
        # Run with explicit environment variables to ensure dmtools sees them
        # Capture both stdout and stderr, and also save exit code
        if [ -n "${ENCODED_CONFIG}" ]; then
          echo "Encoded config provided"
          set +e  # Don't exit on error, we'll handle it manually
          env DMTOOLS_INTEGRATIONS="${DMTOOLS_INTEGRATIONS}" \
              GEMINI_API_KEY="${GEMINI_API_KEY:-}" \
            dmtools run "${CONFIG_FILE}" "${ENCODED_CONFIG}" 2>&1 | tee /tmp/dmtools-output.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e  # Re-enable exit on error
        else
          echo "No encoded config"
          set +e  # Don't exit on error, we'll handle it manually
          env DMTOOLS_INTEGRATIONS="${DMTOOLS_INTEGRATIONS}" \
              GEMINI_API_KEY="${GEMINI_API_KEY:-}" \
            dmtools run "${CONFIG_FILE}" 2>&1 | tee /tmp/dmtools-output.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e  # Re-enable exit on error
        fi
        
        echo ""
        echo "=== dmtools finished with exit code: $EXIT_CODE ==="
        
        # Check exit code and provide helpful error message
        if [ $EXIT_CODE -ne 0 ]; then
          echo ""
          echo "❌ dmtools exited with code: $EXIT_CODE"
          echo ""
          echo "=== Full dmtools output ==="
          cat /tmp/dmtools-output.log 2>/dev/null || echo "Could not read output log"
          echo "=========================="
          echo ""
          echo "=== Additional Debug Info ==="
          echo "DMTOOLS_INTEGRATIONS value: '${DMTOOLS_INTEGRATIONS}'"
          echo "GEMINI_API_KEY: ${GEMINI_API_KEY:+<set>}${GEMINI_API_KEY:-<not set>}"
          echo "Config file path: ${CONFIG_FILE}"
          echo "Config file exists: $([ -f "${CONFIG_FILE}" ] && echo 'yes' || echo 'no')"
          echo "Checking for output files..."
          ls -la outputs/ 2>/dev/null || echo "No outputs/ directory"
          ls -la inputs/ 2>/dev/null || echo "No inputs/ directory"
          echo ""
          echo "Checking if cliCommands were executed..."
          if [ -f "outputs/response.md" ]; then
            echo "✅ outputs/response.md exists:"
            cat outputs/response.md || echo "Could not read response.md"
          else
            echo "❌ outputs/response.md does not exist - cliCommands may not have executed"
          fi
          echo ""
          echo "Config file content:"
          cat "${CONFIG_FILE}" || echo "Could not read config file"
          echo "======================"
          
          # Try to get more verbose output if available
          echo ""
          echo "=== Checking dmtools help/version for clues ==="
          dmtools --version 2>&1 || true
          echo "=============================================="
          
          exit $EXIT_CODE
        else
          echo "✅ dmtools completed successfully"
          echo "Output files:"
          ls -la outputs/ 2>/dev/null || echo "No outputs created"
        fi

    # ✅ ИСПРАВЛЕНО: Добавлена проверка существования папок
    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ai-teammate-results-${{ github.run_number }}
        path: |
          outputs/
          inputs/
        retention-days: 30
        if-no-files-found: warn